// Generation Manager - Business logic layer orchestrating UI, events, and data for image generation
class GenerationManager {
    constructor() {
        this.ui = new window.GenerationUI();
        this.data = new window.GenerationData();
        this.events = new window.GenerationEvents(this);

        // State management
        this.isGenerating = false;
        this.autoGenerationCounter = 0;
        this.autoGenerationMax = 1;
        this.isAutoGenerating = false;
        this.isAutoGeneratedClick = false;  // Flag to track if current generation is auto-triggered

        this.isInitialized = false;
    }

    init() {

        this.events.setupEventListeners();
        this.updateUI();
        this.isInitialized = true;

    }

    // Public API Methods - Backward compatibility

    // State Management
    resetAutoGeneration() {
        this.autoGenerationCounter = 0;
        this.isAutoGenerating = false;
    }

    setGeneratingState(generating) {
        this.isGenerating = generating;
        if (generating) {
            this.ui.showLoadingState();
        } else {
            this.ui.hideLoadingState();
        }
    }

    // Data Methods
    getPromptData() {
        return this.data.extractFormData();
    }

    validatePrompt(promptObj) {
        const validation = this.data.validatePrompt(promptObj);

        if (!validation.isValid) {
            this.ui.showValidationError(validation.errors);
        }

        return validation.isValid;
    }

    // UI Update Methods
    updateUI() {
        this.updateProviderStatus();
    }

    updateProviderStatus() {
        const checkedProviders = this.ui.getProviderCheckboxes();
        const generateBtn = this.ui.getGenerateButton();

        if (generateBtn) {
            if (checkedProviders.length === 0) {
                this.ui.updateButtonState(generateBtn, true, 'Please select at least one provider');
            } else {
                const providerNames = Array.from(checkedProviders).map(p => p.value).join(', ');

                this.ui.updateButtonState(generateBtn, false, `Selected providers: ${providerNames}`);
            }
        }
    }

    updateAutoGenerationStatus() {
        this.ui.updateAutoGenerationStatus(
            this.isAutoGenerating,
            this.autoGenerationCounter,
            this.autoGenerationMax
        );
    }

    // Core Generation Methods
    async generateImage(promptObj) {

        // Set generating state
        this.setGeneratingState(true);
        try {
            // Use the existing generateImage function from modules/images.js
            if (typeof window.generateImage === 'function') {
                const _result = await window.generateImage(promptObj.prompt, promptObj.providers, promptObj);

                // Note: imageGenerated event is already dispatched by images.js

                // Note: Auto-generation continue check is handled by imagesManager after successful generation

                return _result;
            } else {
                console.error('‚ùå window.generateImage function not found');
                this.ui.showError('Image generation not available');
                throw new Error('Image generation not available');
            }
        } catch (error) {
            console.error('‚ùå Image generation failed:', error);
            this.ui.showError(`Error generating image: ${error.message}`);
            throw error;
        } finally {
            // Always reset generating state
            this.setGeneratingState(false);
        }
    }

    // Auto-generation Methods
    stopAutoGeneration() {
        if (this.isAutoGenerating) {
            this.isAutoGenerating = false;
            this.autoGenerationCounter = 0;

            this.updateAutoGenerationStatus();
        }
    }

    checkAutoGenerationContinue() {
        const settings = this.data.extractAutoGenerationSettings();

        if (!settings.isEnabled) {

            return;
        }

        // Get current maxNum value (user might have changed it)
        const { maxNum } = settings;

        if (!this.isAutoGenerating) {
            this.autoGenerationCounter = 0;
            this.autoGenerationMax = maxNum;
            this.isAutoGenerating = true;

        }

        this.autoGenerationCounter++;
        this.updateAutoGenerationStatus();
        if (this.autoGenerationCounter < this.autoGenerationMax) {

            setTimeout(() => {
                this.generateNextImage();
            }, 1000);
        } else {

            this.stopAutoGeneration();
        }
    }

    generateNextImage() {
        console.log('üîÑ AUTO-GENERATE: Triggering next image generation');

        // Set flag to indicate this is an auto-generated click
        this.isAutoGeneratedClick = true;

        // Instead of calling generateImage directly, simulate a click on the START button
        // This ensures all the normal UI flow happens: button states, loading placeholders, etc.
        const startButton = document.querySelector('.btn-generate');

        if (startButton) {
            console.log('üîÑ AUTO-GENERATE: Simulating START button click');
            startButton.click();
        } else {
            console.error('‚ùå AUTO-GENERATE: START button not found, falling back to direct generation');

            // Fallback to direct generation if button not found
            const promptObj = this.getPromptData();

            if (!this.validatePrompt(promptObj)) {
                this.stopAutoGeneration();

                return;
            }
            this.generateImage(promptObj);
        }

        // Reset the flag after a short delay (the click is processed asynchronously)
        setTimeout(() => {
            this.isAutoGeneratedClick = false;
        }, 100);
    }

    // Public Status Methods
    getStatus() {
        return {
            isGenerating: this.isGenerating,
            autoGenerationCounter: this.autoGenerationCounter,
            autoGenerationMax: this.autoGenerationMax,
            isAutoGenerating: this.isAutoGenerating,
            isInitialized: this.isInitialized
        };
    }

    // Configuration Methods
    updateValidationRules(newRules) {
        this.data.updateValidationRules(newRules);
    }

    getValidationRules() {
        return this.data.getValidationRules();
    }

    // Statistics Methods
    getGenerationStats() {
        return this.data.getGenerationStats();
    }

    // Export/Import Methods
    exportGenerationSettings() {
        return this.data.exportGenerationSettings();
    }

    importGenerationSettings(settings) {
        return this.data.importGenerationSettings(settings);
    }

    // Prompt Analysis
    analyzePrompt(prompt) {
        return this.data.analyzePrompt(prompt);
    }

    // Provider Management
    validateProviders(_providers) {
        return this.data.validateProviders(_providers);
    }

    // Error Handling
    handleError(error, context = '') {
        console.error(`‚ùå Generation Manager Error${context ? ` (${context})` : ''}:`, error);
        this.ui.showError(`Generation error: ${error.message}`);
    }

    // Cleanup Methods
    cleanup() {
        this.events.cleanup();
        this.isInitialized = false;
    }

    // Re-initialization
    reInitialize() {

        this.cleanup();
        this.init();
    }

    // Debug Methods
    enableDebugMode() {
        console.log('üîß Debug mode enabled');
    }

    disableDebugMode() {
        console.log('üîß Debug mode disabled');
    }

    // Performance Monitoring
    startPerformanceTimer() {
        this.performanceStartTime = Date.now();
    }

    endPerformanceTimer() {
        if (this.performanceStartTime) {
            const duration = Date.now() - this.performanceStartTime;

            this.performanceStartTime = null;

            return duration;
        }

        return 0;
    }
}

// Export for global access
if (typeof window !== 'undefined') {
    window.GenerationManager = GenerationManager;
}
